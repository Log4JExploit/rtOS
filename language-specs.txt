### Abstract ###

This document contains the syntax and grammer
of the runtimeOS script language.

### Document Syntax ###

{x}: One or more of x
[x]: One ore zero of x
(a | b): either a or b
_any: any character
33-123: any number between 33 and 123, including 33 and 123
x-x: any range of symbols, where x is the actual character (alpha, digits, etc.), including x. 
!x-!x: any range of sybols, where x is the number substitute found for the actual character in the ascii table, including x. Must be positive Integer smaller than or equal to 255.
utf8: any utf8 character
utf16: any utf16 character
(utf8 | utf16)-nonctrl: any non-control character, meaning the exclusion of characters !0-!31 
newline: a literal new line character (aka \n)

### Definitions ###

Identifier:
   a-z { ( a-z | A-Z | 0-9 | $ ) }

BaseType:
   bool
   byte
   char
   short
   int
   float
   double
   long
   string

Bool:
   ( true | false )

Newline:
   newline
   newline \r

Char:
   ' utf16-nonctrl '

String:
   " { utf16-nonctrl } "

Byte:
   0-255 b

Integer:
   1-9 { 0-9 }

Decimal:
   ( 0 . 0-9 | Integer [ . 0-9 ] ) { 0-9 } ( f | d )

Number:
   Byte
   Integer
   Decimal
   Exponent

Exponent:
   ( Integer | Decimal ) ( e | E ) ( + | - ) Integer 

Value:
   BaseType
   BaseType
   Lambda

ValueList:
   [ Value { , Value } ]

Instruction:
   Create
   Set
   Delete
   For
   While
   If
   Invoke
   Function
   Increment
   Decrement
   Exit

Context: 
   { Instruction } done

Create:
   create Identifier [ : BasicType ] [ set to Value ]

Set:
   set Identifier to ( Value | Identifier )

Delete:
   delete Identifier

Increment:
   ( inc | increment ) Identifier

Decrement:
   ( dec | decrement ) Identifier

LogicalConnect:
   ||
   &&

LogicalNegate:
   !

LogicalCompare:
   <
   >
   <=
   >=

Equals:
   ==

Operator:
   *
   /
   +
   -

Operand:
   ( Identifier | Value )

Calculation:
   ( Operand | ( Calc ) ) Operator ( Operand | ( Calc ) ) { Operator ( Operand | ( Calc ) ) }

NumOrId:
   [ not ] ( Number | Identifier )

Logic:
   ( NumOrId ( LogicalCompare | Equals ) NumOrId ) { LogicalConnect LogicalConstruct }

Exit:
   exit 

For:
   for until [ ( above | below ) ] ( Identifier | Number ) ( up | down ) ( Identifier | Number ) [ set Identifier ] : Context

While:
   while ( Logical | Invoke ) : Context

IfCondition:
  ( FunctionReference | Identifier | Bool | Logical )

Else:
   else [ if IfCondition ] Context

If: 
   if ( FunctionReference | Identifier | Bool | Logical ) : Context

FunctionReference: 
   [ Identifier ] :: Identifier ( ValueList ) 

Invoke:
   invoke FunctionReference

Lambda:
   ( [ Identifier : BasicType { , Identifier : BasicType } ] ) : Context

FunctionDeclaration:
   function Identifier Lambda

### END ###
